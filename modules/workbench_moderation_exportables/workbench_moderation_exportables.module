<?php

function workbench_moderation_exportables_permission() {
  return array(
    'administer_workbench_moderation_exportables' => array(
      'title' => t('Administer workbench moderation exportables'),
      'description' => t(''),
    ),
  );
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function workbench_moderation_exportables_ctools_plugin_directory($module, $plugin) {
  // Most of this module is implemented as an export ui plugin, and the
  // rest is in ctools/includes/workbench_states.inc
  if ($module == 'ctools' && ($plugin == 'export_ui')) {
    dsm($plugin);
    return 'plugins/' . $plugin;
  }
}

/**
 * Load all workbench workflows.
 *
 * @todo, collapse the redundant load_all functions.
 */
function workbench_states_load_all($reset = FALSE) {
  return workbench_moderation_exportables_load_all('states', $reset);
}

/**
 * Create an array of states suitable for FAPI.
 */
function workbench_states_options($label_key = 'admin_title', $reset = FALSE) {
  $states = workbench_states_load_all($reset = FALSE);

  $output = array();
  foreach($states as $state) {
    $output[$state->name] = $state->{$label_key};
  }

  return $output;
}

/**
 * @todo document.
 */
function workbench_states_state_access($state_machine_name, $node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);
  $state = ctools_export_crud_load('workbench_moderation_exportables_states', $state_machine_name);

  $contexts = ctools_context_match_required_contexts($state->requiredcontexts, array($node_context));
  $contexts = ctools_context_load_contexts($state, FALSE, $contexts);

  return ctools_access($state->access, $contexts);
}


/**
 * @todo document.
 *
 * @todo, reduce code duplication with workbench_states_state_access().
 */
function workbench_events_event_access($event_machine_name, $node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);
  $event = ctools_export_crud_load('workbench_moderation_exportables_events', $event_machine_name);

  $contexts = ctools_context_match_required_contexts($event->requiredcontexts, array($node_context));
  $contexts = ctools_context_load_contexts($event, FALSE, $contexts);

  if (!ctools_access($event->access, $contexts)) {
    return FALSE;
  } else {
    return workbench_states_state_access($event->target_state, $node);
  }
}

/**
 * Load a single workbench workflow.
 */
function workbench_workflows_load($name) {
  $cache = &drupal_static('workbench_workflows_load_all', array());

  // We use array_key_exists because failed loads will be NULL and
  // isset() will try to load it again.
  if (!array_key_exists($name, $cache)) {
    ctools_include('export');
    $result = ctools_export_load_object('workbench_moderation_exportables_workflows', 'names', array($name));
    if (isset($result[$name])) {
      $cache[$name] = $result[$name];
    }
    else {
      $cache[$name] = NULL;
    }
  }

  if (isset($cache[$name])) {
    return $cache[$name];
  }
}

/**
 * @todo, document. make event callback.
 */
function workbench_moderation_exportables_load_all($type = 'states', $reset = FALSE) {

  $cache = &drupal_static('workbench_moderation_exportables_load_all', array());

  // We check our own private static because individual minis could have
  // been loaded prior to load all and we need to know that.
  if (empty($cache[$type]) || $reset) {
    $all_loaded = TRUE;
    if ($reset) {
      $cache = array();
    }

    ctools_include('export');
    $type_exportables = ctools_export_load_object('workbench_moderation_exportables_' . $type);

    if ($type == 'workflows') {
      uasort($type_exportables, 'ctools_plugin_sort');
    }

    $cache[$type] = $type_exportables;
  }

  return $cache[$type];
}

/**
 * Load all workbench workflows.
 */
function workbench_workflows_load_all($reset = FALSE) {
  return workbench_moderation_exportables_load_all('workflows', $reset);
}

/**
 * Return the appropriate workflow for a node.
 */
function workbench_workflows_select_workflow($node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);


  $workflows = workbench_workflows_load_all();
  foreach($workflows as $workflow) {

    $contexts = ctools_context_match_required_contexts($workflow->requiredcontexts, array($node_context));
    $contexts = ctools_context_load_contexts($workflow, FALSE, $contexts);

    if (ctools_access($workflow->access, $contexts)) {
      // Return the first workflow for which ctools_access() returns TRUE.
      return $workflow;
    }
  }
  return FALSE;
}
