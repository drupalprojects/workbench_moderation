<?php

/**
 * @file
 * workbench_states module
 *
 * This module allows styles to be created and managed on behalf of modules
 * that implement styles.
 *
 * The workbench_states tool allows recolorable styles to be created via a miniature
 * scripting language. Panels utilizes this to allow administrators to add
 * styles directly to any panel display.
 */


/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function workbench_states_ctools_plugin_directory($module, $plugin) {
  // Most of this module is implemented as an export ui plugin, and the
  // rest is in ctools/includes/workbench_states.inc
  if ($module == 'ctools' && ($plugin == 'export_ui')) {
    return 'plugins/' . $plugin;
  }
}

/**
 * Load all workbench workflows.
 */
function workbench_states_load_all($reset = FALSE) {

  $cache = &drupal_static('workbench_states_load_all', array());
  static $all_loaded = FALSE;

  // We check our own private static because individual minis could have
  // been loaded prior to load all and we need to know that.
  if (!$all_loaded || $reset) {
    $all_loaded = TRUE;
    if ($reset) {
      $cache = array();
    }

    ctools_include('export');
    $workbench_states = ctools_export_load_object('workbench_states');

    // @todo do states need weights?
    //uasort($workbench_states, 'ctools_plugin_sort');

    $cache = $workbench_states;
  }

  return $cache;
}

/**
 * Create an array of states suitable for FAPI.
 */
function workbench_states_options($label_key = 'admin_title', $reset = FALSE) {
  $states = workbench_states_load_all($reset = FALSE);

  $output = array();
  foreach($states as $state) {
    $output[$state->name] = $state->{$label_key};
  }

  return $output;
}

/**
 * @todo document.
 */
function workbench_states_state_access($state_machine_name, $node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);
  $state = ctools_export_crud_load('workbench_states', $state_machine_name);

  $contexts = ctools_context_match_required_contexts($state->requiredcontexts, array($node_context));
  $contexts = ctools_context_load_contexts($state, FALSE, $contexts);

  return ctools_access($state->access, $contexts);
}
