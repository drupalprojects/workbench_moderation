<?php

/**
 * @file
 * Contains workbench_moderation.module.
 *
 * @todo include UI bits of https://www.drupal.org/node/2429153
 * @todo How to remove the live version (i.e. published => draft without new
 *   revision) - i.e. unpublish
 */

use Drupal\Core\Access\AccessResult;
use Drupal\Core\Entity\Display\EntityViewDisplayInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\EntityTypeInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Session\AccountInterface;
use Drupal\node\NodeInterface;
use Drupal\workbench_moderation\Plugin\Menu\EditTab;

/**
 * Implements hook_help().
 */
function workbench_moderation_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the workbench_moderation module.
    case 'help.page.workbench_moderation':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Provides basic moderation for content') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_entity_base_field_info().
 */
function workbench_moderation_entity_base_field_info(EntityTypeInterface $entity_type) {
  return \Drupal::service('workbench_moderation.entity_type')->entityBaseFieldInfo($entity_type);
}

/**
 * Implements hook_module_implements_alter().
 */
function workbench_moderation_module_implements_alter(&$implementations, $hook) {
  /** @var \Drupal\workbench_moderation\InlineEditingDisabler $inline_editing_disabler */
  $inline_editing_disabler = \Drupal::service('workbench_moderation.inline_editing_disabler');
  $inline_editing_disabler->moduleImplementsAlter($implementations, $hook);
}

/**
 * Implements hook_entity_view_alter().
 */
function workbench_moderation_entity_view_alter(&$build, EntityInterface $entity, EntityViewDisplayInterface $display) {
  /** @var \Drupal\workbench_moderation\InlineEditingDisabler $inline_editing_disabler */
  $inline_editing_disabler = \Drupal::service('workbench_moderation.inline_editing_disabler');
  $inline_editing_disabler->entityViewAlter($build, $entity, $display);
}

/**
 * Implements hook_entity_type_alter().
 */
function workbench_moderation_entity_type_alter(array &$entity_types) {
  \Drupal::service('workbench_moderation.entity_type')->entityTypeAlter($entity_types);
}

/**
 * Implements hook_entity_operation().
 */
function workbench_moderation_entity_operation(EntityInterface $entity) {
  return \Drupal::service('workbench_moderation.entity_type')->entityOperation($entity);
}

/**
 * Sets required flag based on enabled state.
 */
function workbench_moderation_entity_bundle_field_info_alter(&$fields, EntityTypeInterface $entity_type, $bundle) {
  return \Drupal::service('workbench_moderation.entity_type')->entityBundleFieldInfoAlter($fields, $entity_type, $bundle);
}

/**
 * Implements hook_entity_load().
 */
function workbench_moderation_entity_storage_load(array $entities, $entity_type_id) {
  return \Drupal::service('workbench_moderation.entity_operations')->entityStorageLoad($entities, $entity_type_id);
}

/**
 * Implements hook_entity_presave().
 */
function workbench_moderation_entity_presave(EntityInterface $entity) {
  return \Drupal::service('workbench_moderation.entity_operations')->entityPresave($entity);
}

/**
 * Implements hook_entity_insert().
 */
function workbench_moderation_entity_insert(EntityInterface $entity) {
  return \Drupal::service('workbench_moderation.entity_operations')->entityInsert($entity);
}

/**
 * Implements hook_entity_update().
 */
function workbench_moderation_entity_update(EntityInterface $entity) {
  return \Drupal::service('workbench_moderation.entity_operations')->entityUpdate($entity);
}

/**
 * Implements hook_local_tasks_alter().
 */
function workbench_moderation_local_tasks_alter(&$local_tasks) {
  $content_entity_type_ids = array_keys(array_filter(\Drupal::entityTypeManager()->getDefinitions(), function (EntityTypeInterface $entity_type) {
    return $entity_type->isRevisionable();
  }));

  foreach ($content_entity_type_ids as $content_entity_type_id) {
    if (isset($local_tasks["entity.$content_entity_type_id.edit_form"])) {
      $local_tasks["entity.$content_entity_type_id.edit_form"]['class'] = EditTab::class;
      $local_tasks["entity.$content_entity_type_id.edit_form"]['entity_type_id'] = $content_entity_type_id;
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function workbench_moderation_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  return \Drupal::service('workbench_moderation.entity_type')->bundleFormAlter($form, $form_state, $form_id);
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Many default node templates rely on $page to determine whether to output the
 * node title as part of the node content.
 */
function workbench_moderation_preprocess_node(&$variables) {
  \Drupal::service('workbench_moderation.workbench_preprocess')->preprocessNode($variables);
}

/**
 * Implements hook_entity_extra_field_info().
 */
function workbench_moderation_entity_extra_field_info() {
  return \Drupal::service('workbench_moderation.entity_type')->entityExtraFieldInfo();
}

/**
 * Implements hook_entity_view().
 */
function workbench_moderation_entity_view(array &$build, EntityInterface $entity, EntityViewDisplayInterface $display, $view_mode) {
  \Drupal::service('workbench_moderation.entity_operations')->entityView($build, $entity, $display, $view_mode);
}

/**
 * Implements hook_entity_access().
 *
 * Nodes in particular should be viewable if unpublished and the user has
 * the appropriate permission. This permission is therefore effectively
 * mandatory for any user that wants to moderate things.
 */
function workbench_moderation_node_access(NodeInterface $entity, $operation, AccountInterface $account) {
  /** @var \Drupal\workbench_moderation\ModerationInformationInterface $modinfo */
  $moderation_info = Drupal::service('workbench_moderation.moderation_information');

  if ($operation == 'view') {
    return (!$entity->isPublished())
      ? AccessResult::allowedIfHasPermission($account, 'view any unpublished content')
      : AccessResult::neutral();
  }
  elseif ($operation == 'update' && $moderation_info->isModeratableEntity($entity) && $entity->moderation_information && $entity->moderation_information->target_id) {
    /** @var \Drupal\workbench_moderation\StateTransitionValidation $transition_validation */
    $transition_validation = \Drupal::service('workbench_moderation.state_transition_validation');

    return $transition_validation->getValidTransitionTargets($entity, $account)
      ? AccessResult::neutral()
      : AccessResult::forbidden();
  }
}

/**
 * Implements hook_theme().
 */
function workbench_moderation_theme($existing, $type, $theme, $path) {
  $themes['entity_moderation_form'] = [
    'render element' => 'form',
  ];

  return $themes;
}


function hook_views_data() {
  // This example describes how to write hook_views_data() for a table defined
  // like this:
  // CREATE TABLE workbench_revision_tracker (
  //   nid INT(11) NOT NULL         COMMENT 'Primary key: {node}.nid.',
  //   plain_text_field VARCHAR(32) COMMENT 'Just a plain text field.',
  //   numeric_field INT(11)        COMMENT 'Just a numeric field.',
  //   boolean_field INT(1)         COMMENT 'Just an on/off field.',
  //   timestamp_field INT(8)       COMMENT 'Just a timestamp field.',
  //   langcode VARCHAR(12)         COMMENT 'Language code field.',
  //   PRIMARY KEY(nid)
  // );

  // Define the return array.
  $data = array();

  // The outermost keys of $data are Views table names, which should usually
  // be the same as the hook_schema() table names.
  $data['workbench_revision_tracker'] = [];

  // The value corresponding to key 'table' gives properties of the table
  // itself.
  $data['workbench_revision_tracker']['table'] = [];

  // Within 'table', the value of 'group' (translated string) is used as a
  // prefix in Views UI for this table's fields, filters, etc. When adding
  // a field, filter, etc. you can also filter by the group.
  // @todo Should this be in its own Workbench group or no?
  $data['workbench_revision_tracker']['table']['group'] = t('Content revision');

  // Within 'table', the value of 'provider' is the module that provides schema
  // or the entity type that causes the table to exist. Setting this ensures
  // that views have the correct dependencies. This is automatically set to the
  // module that implements hook_views_data().
  $data['workbench_revision_tracker']['table']['provider'] = 'workbench_moderation';

  // Some tables have an implicit, automatic relationship to other tables,
  // meaning that when the other table is available in a view (either as the
  // base table or through a relationship), this table's fields, filters, etc.
  // are automatically made available without having to add an additional
  // relationship. To define an implicit relationship that will make your
  // table automatically available when another table is present, add a 'join'
  // section to your 'table' section. Note that it is usually only a good idea
  // to do this for one-to-one joins, because otherwise your automatic join
  // will add more rows to the view. It is also not a good idea to do this if
  // most views won't need your table -- if that is the case, define a
  // relationship instead (see below).
  //
  // If you've decided an automatic join is a good idea, here's how to do it;
  // the resulting SQL query will look something like this:
  //   ... FROM workbench_revision_tracker et ... JOIN node_field_data nfd
  //   ON et.nid = nfd.nid AND ('extra' clauses will be here) ...
  // although the table aliases will be different.

  // @todo This will need to iterate on all revisionable entity base tables, I think?

  $data['workbench_revision_tracker']['table']['join'] = [
    // Within the 'join' section, list one or more tables to automatically
    // join to. In this example, every time 'node_field_data' is available in
    // a view, 'workbench_revision_tracker' will be too. The array keys here are the array
    // keys for the other tables, given in their hook_views_data()
    // implementations. If the table listed here is from another module's
    // hook_views_data() implementation, make sure your module depends on that
    // other module.
    'node_revision' => array(
      // Primary key field in node_field_data to use in the join.
      'left_field' => 'nid',
      // Foreign key field in workbench_revision_tracker to use in the join.
      'field' => 'nid',
      // 'extra' is an array of additional conditions on the join.
      'extra' => array(
        0 => array(
          // Adds AND node_field_data.published = TRUE to the join.
          'field' => 'published',
          'value' => TRUE,
        ),
        1 => array(
          // Adds AND workbench_revision_tracker.numeric_field = 1 to the join.
          'left_field' => 'numeric_field',
          'value' => 1,
          // If true, the value will not be surrounded in quotes.
          'numeric' => TRUE,
        ),
        2 => array(
          // Adds AND workbench_revision_tracker.boolean_field <>
          // node_field_data.published to the join.
          'field' => 'published',
          'left_field' => 'boolean_field',
          // The operator used, Defaults to "=".
          'operator' => '!=',
        ),
      ),
    ),
  ];

  // You can also do a more complex join, where in order to get to a certain
  // base table defined in a hook_views_data() implementation, you will join
  // to a different table that Views knows how to auto-join to the base table.
  // For instance, if another module that your module depends on had
  // defined a table 'foo' with an automatic join to 'node_field_table' (as
  // shown above), you could join to 'node_field_table' via the 'foo' table.
  // Here's how to do this, and the resulting SQL query would look something
  // like this:
  //   ... FROM workbench_revision_tracker et ... JOIN foo foo
  //   ON et.nid = foo.nid AND ('extra' clauses will be here) ...
  //   JOIN node_field_data nfd ON (definition of the join from the foo
  //   module goes here) ...
  // although the table aliases will be different.
  $data['workbench_revision_tracker']['table']['join']['node_field_data'] = array(
    // 'node_field_data' above is the base we're joining to in Views.
    // 'left_table' is the table we're actually joining to, in order to get to
    // 'node_field_data'. It has to be something that Views knows how to join
    // to 'node_field_data'.
    'left_table' => 'foo',
    'left_field' => 'nid',
    'field' => 'nid',
    // 'extra' is an array of additional conditions on the join.
    'extra' => array(
      // This syntax matches additional fields in the two tables:
      // ... AND foo.langcode = workbench_revision_tracker.langcode ...
      array('left_field' => 'langcode', 'field' => 'langcode'),
      // This syntax adds a condition on our table. 'operator' defaults to
      // '=' for non-array values, or 'IN' for array values.
      // ... AND workbench_revision_tracker.numeric_field > 0 ...
      array('field' => 'numeric_field', 'value' => 0, 'numeric' => TRUE, 'operator' => '>'),
    ),
  );

  // Other array elements at the top level of your table's array describe
  // individual database table fields made available to Views. The array keys
  // are the names (unique within the table) used by Views for the fields,
  // usually equal to the database field names.
  //
  // Each field entry must have the following elements:
  // - title: Translated label for the field in the UI.
  // - help: Description of the field in the UI.
  //
  // Each field entry may also have one or more of the following elements,
  // describing "handlers" (plugins) for the field:
  // - relationship: Specifies a handler that allows this field to be used
  //   to define a relationship to another table in Views.
  // - field: Specifies a handler to make it available to Views as a field.
  // - filter: Specifies a handler to make it available to Views as a filter.
  // - sort: Specifies a handler to make it available to Views as a sort.
  // - argument: Specifies a handler to make it available to Views as an
  //   argument, or contextual filter as it is known in the UI.
  // - area: Specifies a handler to make it available to Views to add content
  //   to the header, footer, or as no result behavior.
  //
  // Note that when specifying handlers, you must give the handler plugin ID
  // and you may also specify overrides for various settings that make up the
  // plugin definition. See examples below; the Boolean example demonstrates
  // setting overrides.

  // Node ID field, exposed as relationship only, since it is a foreign key
  // in this table.
  $data['workbench_revision_tracker']['nid'] = array(
    'title' => t('Example content'),
    'help' => t('Relate example content to the node content'),

    // Define a relationship to the node_field_data table, so views whose
    // base table is workbench_revision_tracker can add a relationship to nodes. To make a
    // relationship in the other direction, you can:
    // - Use hook_views_data_alter() -- see the function body example on that
    //   hook for details.
    // - Use the implicit join method described above.
    'relationship' => array(
      // Views name of the table to join to for the relationship.
      'base' => 'node_field_data',
      // Database field name in the other table to join on.
      'base field' => 'nid',
      // ID of relationship handler plugin to use.
      'id' => 'standard',
      // Default label for relationship in the UI.
      'label' => t('Example node'),
    ),
  );

  // Plain text field, exposed as a field, sort, filter, and argument.
  $data['workbench_revision_tracker']['plain_text_field'] = array(
    'title' => t('Plain text field'),
    'help' => t('Just a plain text field.'),

    'field' => array(
      // ID of field handler plugin to use.
      'id' => 'standard',
    ),

    'sort' => array(
      // ID of sort handler plugin to use.
      'id' => 'standard',
    ),

    'filter' => array(
      // ID of filter handler plugin to use.
      'id' => 'string',
    ),

    'argument' => array(
      // ID of argument handler plugin to use.
      'id' => 'string',
    ),
  );

  // Numeric field, exposed as a field, sort, filter, and argument.
  $data['workbench_revision_tracker']['numeric_field'] = array(
    'title' => t('Numeric field'),
    'help' => t('Just a numeric field.'),

    'field' => array(
      // ID of field handler plugin to use.
      'id' => 'numeric',
    ),

    'sort' => array(
      // ID of sort handler plugin to use.
      'id' => 'standard',
    ),

    'filter' => array(
      // ID of filter handler plugin to use.
      'id' => 'numeric',
    ),

    'argument' => array(
      // ID of argument handler plugin to use.
      'id' => 'numeric',
    ),
  );

  // Boolean field, exposed as a field, sort, and filter. The filter section
  // illustrates overriding various settings.
  $data['workbench_revision_tracker']['boolean_field'] = array(
    'title' => t('Boolean field'),
    'help' => t('Just an on/off field.'),

    'field' => array(
      // ID of field handler plugin to use.
      'id' => 'boolean',
    ),

    'sort' => array(
      // ID of sort handler plugin to use.
      'id' => 'standard',
    ),

    'filter' => array(
      // ID of filter handler plugin to use.
      'id' => 'boolean',
      // Override the generic field title, so that the filter uses a different
      // label in the UI.
      'label' => t('Published'),
      // Override the default BooleanOperator filter handler's 'type' setting,
      // to display this as a "Yes/No" filter instead of a "True/False" filter.
      'type' => 'yes-no',
      // Override the default Boolean filter handler's 'use_equal' setting, to
      // make the query use 'boolean_field = 1' instead of 'boolean_field <> 0'.
      'use_equal' => TRUE,
    ),
  );

  // Integer timestamp field, exposed as a field, sort, and filter.
  $data['workbench_revision_tracker']['timestamp_field'] = array(
    'title' => t('Timestamp field'),
    'help' => t('Just a timestamp field.'),

    'field' => array(
      // ID of field handler plugin to use.
      'id' => 'date',
    ),

    'sort' => array(
      // ID of sort handler plugin to use.
      'id' => 'date',
    ),

    'filter' => array(
      // ID of filter handler plugin to use.
      'id' => 'date',
    ),
  );

  // Area example. Areas are not generally associated with actual data
  // tables and fields. This example is from views_views_data(), which defines
  // the "Global" table (not really a table, but a group of Fields, Filters,
  // etc. that are grouped into section "Global" in the UI). Here's the
  // definition of the generic "Text area":
  $data['views']['area'] = array(
    'title' => t('Text area'),
    'help' => t('Provide markup text for the area.'),
    'area' => array(
      // ID of the area handler plugin to use.
      'id' => 'text',
    ),
  );

  return $data;
}
