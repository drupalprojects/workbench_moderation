<?php

/**
 * Implements hook_views_api().
 */
 function workbench_moderation_views_api() {
   // @todo, Should this be 3.0?
   return array('api' => 2.0);
}

/**
 * Implements hook_menu_alter().
 */
function workbench_moderation_menu_alter(&$items) {

  // Redirect node/%node/revisions
  $items['node/%node/revisions']['page callback'] = 'workbench_moderation_node_revisions_redirect';
  $items['node/%node/revisions']['page arguments'] = array(1);
  $items['node/%node/revisions']['type'] = MENU_NORMAL_ITEM;

  // Redirect node/%node/workflow
  if (!empty($items['node/%node/workflow']) && $items['node/%node/workflow']['module'] === 'state_flow') {
    // @todo, Uncomment this when the moderation tab is ready.
    // $items['node/%node/workflow']['page callback'] = 'workbench_moderation_node_revisions_redirect';
    // $items['node/%node/workflow']['page arguments'] = array(1);
    // $items['node/%node/workflow']['type'] = MENU_NORMAL_ITEM;
  }

  /**
   * @todo, revisit these alters from version 1.x

  // Override the node revision view callback.
  $items['node/%node/revisions/%/view']['page callback'] = 'workbench_moderation_node_view_revision';
  $items['node/%node/revisions/%/view']['file path'] = drupal_get_path('module', 'workbench_moderation');
  $items['node/%node/revisions/%/view']['file'] = 'workbench_moderation.node.inc';

  // For revert and delete operations, use our own access check.
  $items['node/%node/revisions/%/revert']['access callback'] = '_workbench_moderation_revision_access';
  $items['node/%node/revisions/%/delete']['access callback'] = '_workbench_moderation_revision_access';

  // Provide a container administration menu item, if one doesn't already exist.
  if (!isset($items['admin/config/workbench'])) {
    $items['admin/config/workbench'] = array(
      'title' => 'Workbench',
      'description' => 'Workbench',
      'page callback' => 'system_admin_menu_block_page',
      'access arguments' => array('administer site configuration'),
      'position' => 'right',
      'file' => 'system.admin.inc',
      'file path' => drupal_get_path('module', 'system'),
    );
  }
   *
   *
   */
}

/**
 * Implements hook_permission().
 *
 * Provides permissions for each state to state change.
 */
function workbench_moderation_permission() {
  $permissions = array();
  // @todo which perms do we need in 2.x
  /*$permissions['view all unpublished content'] = array(
    'title' => t('View all unpublished content'),
  );
  $permissions['administer workbench moderation'] = array(
    'title' => t('Administer Workbench Moderation'),
  );
  $permissions['bypass workbench moderation'] = array(
    'title' => t('Bypass moderation restrictions'),
    'restrict access' => TRUE,
  );
  $permissions['view moderation history'] = array(
    'title' => t('View moderation history'),
  );
  $permissions['view moderation messages'] = array(
    'title' => t('View the moderation messages on a node')
  );*/

  $permissions['use workbench_moderation my drafts tab'] = array(
    'title' => t('Use "My Drafts" workbench tab')
  );
  $permissions['use workbench_moderation needs review tab'] = array(
    'title' => t('Use "Needs Review" workbench tab')
  );

  return $permissions;
}

/**
 * Redirects 'node/%node/revisions' to node/%node/moderation
 *
 * workbench_moderation_menu_alter() changes the page callback
 * for 'node/%node/revisions' to this function
 *
 * @param $node
 *   The node being acted upon.
 */
function workbench_moderation_node_revisions_redirect($node) {

  drupal_goto('node/' . $node->nid . '/moderation');

  /**
   * @todo Revisit this additional logic from version 1.x
  // Redirect node types subject to moderation.
  if (workbench_moderation_node_type_moderated($node->type) === TRUE) {
    drupal_goto('node/' . $node->nid . '/moderation');
  }
  // Return the normal node revisions page for unmoderated types.
  else {

    if (module_exists('diff')) {
      return diff_diffs_overview($node);
    }
    else {
      return node_revision_overview($node);
    }
  }
   *
   */
}






















































/**
 * Implements hook_node_view().
 *
 * Display messages about the node's moderation state.
 */
function workbench_moderation_node_view($node, $view_mode = 'full') {

  //dsm($node);

  // Show moderation state messages if we're on a node page.
  if (node_is_page($node) && $view_mode == 'full' && empty($node->in_preview)) {
    workbench_moderation_messages('view', $node);
  }
}











/**
 * Implements hook_block_view_workbench_block().
 *
 * Show the editorial status of this node.
 */
function workbench_moderation_workbench_block() {




  $output = array('HELLLO!!!');
  foreach (workbench_moderation_set_message() as $message) {
    $output[] = t('!label: <em>!message</em>', array('!label' => $message['label'], '!message' => $message['message']));
  }

  return $output;
}




/**
 * Stores status messages for delivery.
 *
 * This function stores up moderation messages to be passed on to workbench_moderation_workbench_block().
 *
 * This function uses a static variable so that function can be called more than
 * once and the array built up.
 *
 * @see workbench_moderation_workbench_block()
 * @see workbench_moderation_messages()
 *
 * @param $new_messages
 *   An array of messages to be added to the block.
 *
 * @return
 *   An array of messages to be added to the block.
 */
function workbench_moderation_set_message($new_messages = array()) {
  static $messages = array();
  $messages = array_merge($messages, $new_messages);
  return $messages;
}




/**
 * Sets status messages for a node.
 *
 * Note that these status messages aren't relevant to the session, only the
 * current page view.
 *
 * @see workbench_moderation_set_message()
 *
 * @param $context
 *   A string, either 'view' or 'edit'.
 * @param $node
 *   A node object. The current menu object will be used if it is a node and
 *   this variable was not set.
 */
function workbench_moderation_messages($context, $node = NULL) {

  $info_block_messages = array();

  global $user;
  if (!user_access('view moderation messages')
      || (!$node && !($node = menu_get_object()))) {
    return;
  }


  if ($state_machine = state_flow_entity_load_state_machine($node, 'vid') && !empty($node->current_state)) {
   // dsm($node->current_state);

    $info_block_messages[] = array(
      'label' => t('Revision state'),
      'message' => check_plain(workbench_workflows_load_label('states', $node->current_state)),
    );
  // Send the info block array to a static variable.
  workbench_moderation_set_message($info_block_messages);


}
/*
  dsm($state_machine);
  dsm($node);

  if

  current_state
 *
 *
 */

}
  /*


  $node_published = FALSE;
  $revision_published = FALSE;
  $revision_current = FALSE;

  // For new content, this property will not be set.
  if (isset($node->workbench_moderation)) {
    $state = $node->workbench_moderation;
    if (!empty($state['published'])) {
      $node_published = TRUE;
    }
    if ($state['my_revision']->published) {
      $revision_published = TRUE;
    }
    if ($state['my_revision']->vid == $state['current']->vid) {
      $revision_current = TRUE;
    }
  }

  // An array of messages to add to the general workbench block.
  $info_block_messages = array();

  if ($context == 'view') {
    $info_block_messages[] = array(
      'label' => t('Revision state'),
      'message' => check_plain(workbench_moderation_state_label($state['my_revision']->state)),
    );
    $info_block_messages[] = array(
      'label' => t('Current draft'),
      'message' => !empty($revision_current) ? t('Yes') : t('No'),
    );

    // Check node access.
    drupal_static('_node_revision_access', array(), TRUE);

    // Add a moderation form.
    if ($revision_current && !$revision_published && _workbench_moderation_access('update', $node) && $moderate_form = drupal_get_form('workbench_moderation_moderate_form', $node, "node/{$node->nid}/current-revision")) {
      if ($moderate_form = drupal_render($moderate_form)) {
        $info_block_messages[] = array(
          'label' => t('Moderate'),
          'message' => $moderate_form,
        );
      }
    }

    // Add an unpublish link.
    $next_states = workbench_moderation_states_next(workbench_moderation_state_published(), $user, $node->type);
    if ($revision_published && !empty($next_states) && $link = workbench_moderation_access_link(t('Unpublish this revision'), "node/{$node->nid}/moderation/{$node->vid}/unpublish")) {
      $info_block_messages[] = array(
        'label' => t('Actions'),
        'message' => $link,
      );
    }

    // Revision navigation links. This is disabled for the time being, since
    // node tabs are lost when navigating through old revisions.
    // @TODO remove this entirely?
    if (variable_get('workbench_moderation_show_revision_navigation', FALSE) && user_access('view revisions')) {
      $links = array();

      // Get previous and next revision ids.
      $args = array(':nid' => $node->nid, ':vid' => $node->vid);
      if ($prev_vid = db_query_range("SELECT nr.vid FROM {node_revision} nr WHERE nr.nid = :nid AND nr.vid < :vid ORDER BY nr.vid DESC", 0, 1, $args)->fetchField()) {
        $links[$prev_vid] = array('title' => t('Previous revision'), 'href' => "node/{$node->nid}/revisions/{$prev_vid}/view");
      }
      if ($next_vid = db_query_range("SELECT nr.vid FROM {node_revision} nr WHERE nr.nid = :nid AND nr.vid > :vid ORDER BY nr.vid ASC", 0, 1, $args)->fetchField()) {
        $links[$next_vid] = array('title' => t('Next revision'), 'href' => "node/{$node->nid}/revisions/{$next_vid}/view");
      }

      // If the current revision is next or previous, use the "node/%node/current-revision" path.
      if (($current = $state['current']->vid) && isset($links[$current])) {
        $links[$current]['href'] = "node/{$node->nid}/current-revision";
      }

      // If the published revision is next or previous, use the "node/%node" path.
      if (isset($state['published']) && ($published = $state['published']->vid) && isset($links[$published])) {
        $links[$published]['href'] = "node/{$node->nid}";
      }

      // Link it up, with access checks.
      foreach ($links as $key => $args) {
        $links[$key] = call_user_func_array('workbench_moderation_access_link', $args);
      }

      // Post the links in a non-repeating message.
      if (!empty($links)) {
        $info_block_messages[] = array(
          'label' => t('View'),
          'message' => implode(', ', $links),
        );
      }
    }
  }
  // @TODO: Clean these up.
  elseif ($context == 'edit') {
    if ($node_published && $revision_published) {
      $info_block_messages[] = array(
        'label' => t('Status'),
        'message' => t('New draft of live content.'),
      );
    }
    elseif ($node_published && !$revision_published) {
      $info_block_messages[] = array(
        'label' => t('Status'),
        'message' => t('New draft from current revision'),
      );
      $link = workbench_moderation_access_link(t('Create a new draft from the published revision.'), "node/{$node->nid}/revisions/{$state['published']->vid}/revert");
      $info_block_messages[] = array(
        'label' => t('Actions'),
        'message' => $link,
      );
    }
    else {
      // New content.
      $info_block_messages[] = array(
        'label' => t('New content'),
        'message' => t('Your draft will be placed in moderation.'),
      );
    }
  }

  // Send the info block array to a static variable.
  workbench_moderation_set_message($info_block_messages);
}

/**
 * Builds a link for use in messages.
 *
 * @see workbench_moderation_messages()
 *
 * @param $text
 *   The link text to use.
 * @param $internal_path
 *   The Drupal path for the link.
 * @param $options
 *   Link options, following the format of url().
 *
 * @return
 *   A drupal-formatted HTML link.
 *   /
function workbench_moderation_access_link($text, $internal_path, $options = array()) {
  if (($item = menu_get_item($internal_path)) && !empty($item['access'])) {
    return l($text, $internal_path, $options);
  }
}
*/
