<?php

/**
 * @file workbench_workflows.module
 *
 * This module provides workbench workflows which are basically panels that can be
 * used within blocks or other panels.
 */

/**
 * Implementation of hook_permission().
 */
function workbench_workflows_permission() {
  return array(
    'create workbench workflows' => array(
      'title' => t('Create workbench workflows'),
      'description' => t('Create new workbench workflows'),
    ),
    'administer workbench workflows' => array(
      'title' => t('Administer workbench workflows'),
      'description' => t('Edit and delete workbench workflows'),
    ),
  );
}


// ---------------------------------------------------------------------------
// Allow the rest of the system access to workbench workflows


/**
 * Statically store all used IDs to ensure all workbench workflows get a unique id.
 */
function workbench_workflows_get_id($name) {
  $id_cache = &drupal_static(__FUNCTION__, array());

  $id = 'workbench-workflow-' . $name;
  if (!empty($id_cache[$name])) {
    $id .= "-" . $id_cache[$name]++;
  }
  else {
    $id_cache[$name] = 1;
  }

  return $id;
}

// ---------------------------------------------------------------------------
// Database functions.

/**
 * Create a new page with defaults appropriately set from schema.
 */
function workbench_workflows_new($set_defaults = TRUE) {
  ctools_include('export');
  return ctools_export_new_object('workbench_workflows', $set_defaults);
}

/**
 * Load a single workbench workflow.
 */
function workbench_workflows_load($name) {
  $cache = &drupal_static('workbench_workflows_load_all', array());

  // We use array_key_exists because failed loads will be NULL and
  // isset() will try to load it again.
  if (!array_key_exists($name, $cache)) {
    ctools_include('export');
    $result = ctools_export_load_object('workbench_workflows', 'names', array($name));
    if (isset($result[$name])) {
      $cache[$name] = $result[$name];
    }
    else {
      $cache[$name] = NULL;
    }
  }

  if (isset($cache[$name])) {
    return $cache[$name];
  }
}

/**
 * Load all workbench workflows.
 */
function workbench_workflows_load_all($reset = FALSE) {
  $cache = &drupal_static('workbench_workflows_load_all', array());
  static $all_loaded = FALSE;

  // We check our own private static because individual minis could have
  // been loaded prior to load all and we need to know that.
  if (!$all_loaded || $reset) {
    $all_loaded = TRUE;
    if ($reset) {
      $cache = array();
    }

    ctools_include('export');
    $workbench_workflows = ctools_export_load_object('workbench_workflows');
    uasort($workbench_workflows, 'ctools_plugin_sort');

    $cache = $workbench_workflows;
  }

  return $cache;
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function workbench_workflows_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Return the appropriate workflow for a node.
 */
function workbench_workflows_select_workflow($node) {

  ctools_include('export');
  ctools_include('context');
  $node_context = ctools_context_create('entity:node', $node);


  $workflows = workbench_workflows_load_all();
  foreach($workflows as $workflow) {

    $contexts = ctools_context_match_required_contexts($workflow->requiredcontexts, array($node_context));
    $contexts = ctools_context_load_contexts($workflow, FALSE, $contexts);

    if (ctools_access($workflow->access, $contexts)) {
      // Return the first workflow for which ctools_access() returns TRUE.
      return $workflow;
    }
  }
  return FALSE;
}
